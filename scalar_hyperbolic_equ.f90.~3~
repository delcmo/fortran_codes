!----------!
!- Module -!
!----------!
module mesh
! number of cells
integer, parameter :: nb_cell = 3
! number of degree of freedom
integer, parameter :: dof = nb_cell+1
! initial left and right values
real, parameter :: u_left = 2.
real, parameter :: u_right = 1.
! bc values
real, parameter :: u_left_bc = 2.
real, parameter :: u_right_bc = 1.
! initial position of the step
real, parameter :: x_step = 0.5
! length and discretization parameters
real, parameter :: L = 1.
real, parameter :: delta_x = L / nb_cell
real, parameter :: delta_t = 0.1
integer, parameter :: p = 1
real, parameter :: Jwx = 0.5*delta_x
end module
!-----------!
!- Program -!
!-----------!
program array
use mesh
implicit none
! interface
interface
! test function
function phi(x,i)
real phi
real, intent(in) :: x
integer, intent(in) :: i
end function phi
! grad test function
function grad_phi(x,i)
real grad_phi
real, intent(in) :: x
integer, intent(in) :: i
end function grad_phi
! flux function
function flux(u,flux_type)
real flux
real, intent(in) :: u
character(len=6), intent(in) :: flux_type
end function flux
! dissipative function
function viscous_flux(grad_u,kappa)
real viscous_flux
real, intent(in) :: grad_u,kappa
end function viscous_flux
! Weight and quadrature points
subroutine quad_pts_and_weight(p, xq, wq)
integer, intent(in) :: p
real, dimension (p+1,1), intent(out) :: xq, wq
end subroutine
! Compute mass matrix
subroutine mass_matrix(p,nb_cell,xq,wq,Jwx,M)
integer, intent(in) :: p,nb_cell
real, intent(in) :: Jwx
real, dimension (p+1,1), intent(in) :: xq,wq
real, dimension (p*nb_cell+1,p*nb_cell*1), intent(out) :: M
end subroutine mass_matrix
! Steady-state residual
subroutine stt_residual(p,nb_cell,xq,wq,Jwx,U,stt_R)
integer, intent(in) :: p,nb_cell
real, intent(in) :: Jwx
real, dimension(p+1,1), intent(in) :: xq,wq
real, dimension(p*nb_cell+1,1), intent(in) :: U
real, dimension(p*nb_cell+1,1), intent(out) :: stt_R
end subroutine stt_residual
! Apply boundry conditions
subroutine apply_bc(u_left_bc,u_right_bc,bc_type,U,stt_R)
real, intent(in) :: u_left_bc,u_right_bc
character(len=7), intent(in) :: bc_type 
real, dimension(:,:), allocatable, intent(inout) :: stt_R
real, dimension(:,:), allocatable, intent(in) :: U
end subroutine apply_bc
end interface
! Declare variables: matrix and vectors
real, dimension(dof,dof) :: Mass
real, dimension(dof,1) :: U,Uold,Uolder,stt_R,stt_R__old,X
integer i_var,j_var, q_var, AllocateStatus
real sum
! Declare vectors storing quadrature potins and weights
real, dimension(p+1,1) :: xq, wq
! Loop to set the initial values
do i_var = 1,dof,1
   X(i_var,1)=(i_var-1)*delta_x
   if (X(i_var,1)<x_step) then 
      U(i_var,1)=u_left
   else
      U(i_var,1)=u_right
   endif
   X(i_var,1)=(i_var-1)*delta_x
end do
Uold=U
Uolder=U
! Call the subroutine to get the quadrature points and weights
call quad_pts_and_weight(p,xq,wq)
print *, p
print *, xq
print *, wq
print *, dof
print *, nb_cell
! Print U and X
print *, U
print *, X
print *, Mass
! Test function
print *, phi(xq(1,1),1)
print *, phi(xq(2,1),1)
print *, phi(xq(1,1),2)
print *, phi(xq(2,1),2)
! Compute mass matrix
Mass(:,:)=0.
print *, size(U)
print *, Mass
call mass_matrix(p,nb_cell,xq,wq,Jwx,Mass)
do i_var = 1,dof,1
   do j_var = 1,dof,1
      print *, "Mass(",i_var,",",j_var,")=", Mass(i_var,j_var)
   end do
end do
! Compute steady-state residual
call stt_residual(p,nb_cell,xq,wq,Jwx,U,stt_R)
! apply bc
!call apply_bc(u_left_bc,u_right_bc,"bc_type",U,stt_R)
do i_var=1,dof,1
   print *, "stt residual(",i_var,",1)=",stt_R(i_var,1)
end do
! Output kernel
!do i_var = 1,nb_cell,1
!   do j_var = 1,nb_cell,1
!   print *, "kernel=", kernel(i_var,j_var)
!   end do
!end do
end program array
! test function
function phi(x,i)
implicit none
real phi
real, intent(in) :: x
integer, intent(in) :: i
if ( i == 1 ) then
phi=0.5*(1-x)
else if (i==2) then
phi=0.5*(1+x)
else
print *, "Wrong integer"
stop
end if
end function phi
! grad test function
function grad_phi(x,i)
implicit none
real grad_phi
real, intent(in) :: x
integer, intent(in) :: i
if (i==1) then
   grad_phi=-0.5
else if (i==2) then
   grad_phi=0.5
else
   print *, "Wrong integer"
end if
end function grad_phi
! flux function
function flux(u,flux_type)
implicit none
real flux
real, intent(in) :: u
character(len=6), intent(in) :: flux_type
select case (flux_type)
case ("burger")
flux=0.5*u*u
case ("linear")
flux=u
case default
print *, "Error: the flux type provided in function 'flux' is not implemented"
stop
end select
end function flux
! dissipative function
function viscous_flux(grad_u,kappa)
implicit none
real viscous_flux
real, intent(in) :: grad_u,kappa
viscous_flux=kappa*grad_u
end function viscous_flux
! weight and quadrature points
subroutine quad_pts_and_weight(p,xq,wq)
implicit none
integer, intent(in) :: p
real, dimension(p+1,1), intent(out) :: xq, wq
integer i_var
do i_var=1,p+1,1
   wq(i_var,1)=1
end do
xq(1,1)=-1./sqrt(3.)
xq(2,1)=1./sqrt(3.)
end subroutine
! mass matrix
subroutine mass_matrix(p,nb_cell,xq,wq,Jwx,M)
implicit none
integer, intent(in) :: p,nb_cell
real, intent(in) :: Jwx
real, dimension(p+1,1), intent(in) :: xq,wq
real, dimension(p*nb_cell+1,p*nb_cell+1), intent(out) :: M
integer row_var,i_var,j_var,q_var,dof
real sum,phi
print *, Jwx
dof=p*nb_cell+1
do row_var=1,nb_cell,p
   do j_var=1,p+1,1
      do i_var=1,p+1,1
         sum=0.
         do q_var=1,p+1,1
            sum=sum + wq(q_var,1)*phi(xq(q_var,1),i_var)*phi(xq(q_var,1),j_var)*Jwx
         end do
         M(row_var+i_var-1,row_var+j_var-1)=M(row_var+i_var-1,row_var+j_var-1)+sum
      end do
   end do
end do
end subroutine mass_matrix
! steady-state residual
subroutine stt_residual(p,nb_cell,xq,wq,Jwx,U,stt_R)
implicit none
integer, intent(in) :: p,nb_cell
real, intent(in) :: Jwx
real, dimension (p+1,1), intent(in) :: xq,wq
real, dimension (p*nb_cell+1,1), intent(in) :: U
real, dimension (p*nb_cell+1,1), intent(out) :: stt_R
integer row_var,i_var,j_var,q_var,dof
real uq,grad_uq,sum,phi,grad_phi,flux,viscous_flux
dof=p*nb_cell+1
stt_R(:,:)=0.
do row_var=1,nb_cell,1
   do j_var=1,p+1,1
      sum=0.
      do q_var=1,p+1,1
         uq=0.
         grad_uq=0.
         do i_var=1,p+1,1
            uq=uq+phi(xq(q_var,1),i_var)*U(p*row_var+i_var-1,1)
            grad_uq=grad_uq+grad_phi(xq(q_var,1),i_var)*U(p*row_var+i_var-1,1)
         end do
         sum=sum+grad_phi(xq(q_var,1),j_var)*flux(uq,"burger")-viscous_flux(grad_uq,0.)*grad_phi(xq(q_var,1),j_var)/Jwx
      end do
      stt_R(p*row_var+j_var-1,1)=sum
   end do
end do
end subroutine stt_residual
! Apply bounday conditions
subroutine apply_bc(u_left_bc,u_right_bc,bc_type,U,stt_R)
implicit none
real, intent(in) :: u_left_bc,u_right_bc
character(len=7), intent(in) :: bc_type 
real, dimension(:,:), allocatable, intent(in) :: U
real, dimension(:,:), allocatable, intent(inout) :: stt_R
real phi, flux
integer size_U
size_U=size(U)
! left bc
stt_R(1,1)=stt_R(1,1)-flux(u_left_bc,"burger")*phi(-1.,1)
! right bc
stt_R(size(U),1)=stt_R(size(U),1)+flux(u_right_bc,"burger")*phi(1.,2)
end subroutine apply_bc
